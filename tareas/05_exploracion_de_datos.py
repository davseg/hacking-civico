# -*- coding: utf-8 -*-
"""05_Exploracion_de_datos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/CodeandoMexico/hacking-civico/blob/master/notebooks/05_Exploracion_de_datos.ipynb

<p align="center">
<img src="http://codeandomexico.org/resources/img/codeandomexico.png" width="500" alt="Codeando M√©xico"><br>
<a href="http://www.codeandomexico.org/" target="_blank"><img src="https://img.shields.io/badge/website-CodeandoMexico-00D88E.svg"></a>
<a href="http://slack.codeandomexico.org/" target="_blank"><img src="https://img.shields.io/badge/slack-CodeandoMexico-EC0E4F.svg"></a>
</p>
<!-- __ -->

# Curso de Datos Abiertos y Hacking C√≠vico

Este curso tiene como objetivo habilitar las capacidades de la ciudadaniÃÅa y los servidores p√∫blicos en el uso y generaci√≥n de datos abiertos para el bien com√∫n. Puedes encontrar m√°s informaci√≥n [aqu√≠](https://github.com/CodeandoMexico/hacking-civico).

# Exploraci√≥n de datos: COVID-19 en M√©xico

En este cuaderno aprenderemos algunas bases de exploraci√≥n de datos. Los datos a utilizar son los datos abiertos sobre COVID-19 en M√©xico, los cuales pueden ser accedidos directamente desde el portal: https://www.gob.mx/salud/documentos/datos-abiertos-152127

Del portal de datos abiertos podemos encontrar dos enlaces, uno para descargar el conjunto de datos y otro para descargar el diccionario; as√≠ que podemos automatizar el proceso de descarga y descompresi√≥n de la informaci√≥n.

Para obtener los datos, s√≥lo basta que ejecutes la siguiente l√≠nea de c√≥digo, que contiene el comando de descarga de la informaci√≥n.
"""

# Para descargar el conjunto de datos
!wget http://datosabiertos.salud.gob.mx/gobmx/salud/datos_abiertos/datos_abiertos_covid19.zip

# Para descargar el diccionario de los datos
!wget http://epidemiologia.salud.gob.mx/gobmx/salud/datos_abiertos/diccionario_datos_covid19.zip

# Descomprimimos ambas carpetas y movemos archivos
!unzip datos_abiertos_covid19.zip
!unzip diccionario_datos_covid19.zip
!mv ./diccionario_datos_covid19/*.xlsx .
!mv *COVID19MEXICO.csv COVID19MEXICO.csv

# Eliminamos las carpetas comprimidas
!rm -rf diccionario_datos_covid19
!rm datos_abiertos_covid19.zip
!rm diccionario_datos_covid19.zip

"""Hasta este punto, si abres la barra lateral izaquiera, deber√≠as ser capaz de encontrar los datos:

- `COVID19MEXICO.csv`
- `Catalogos_0412.xlsx`
- `Descriptores_0419.xlsx`

üëàüèº

## Carga

Ahora que tenemos los datos, procederemos a cargarlos. Para cargar los datos, primero importaremos algunos paquetes de Python, pues su funcionalidad nos ser√° muy util.
"""

import statistics

import pandas as pd
import numpy as np

# Especificamos el nombre del archivo por abrir
nombre_archivo = 'COVID19MEXICO.csv'

# Utilizamos la funci√≥n de Pandas para cargar un archivo CSV
data = pd.read_csv(nombre_archivo, encoding='latin-1')

"""Mostramos la cabeza (primeros elementos del archivo)."""

data.head()

"""Ahora procedemos a cargar el archivo con los descriptores."""

nombre_diccionario = 'Descriptores_0419.xlsx'
diccionario = pd.read_excel(nombre_diccionario)

diccionario

"""Finalmente, cargamos el rachivo de cat√°logos."""

nombre_cat = 'Catalogos_0412.xlsx'
sheets = ['ORIGEN', 'SECTOR', 'SEXO', 'TIPO_PACIENTE', 'SI_NO', 'NACIONALIDAD', 'RESULTADO', 'de ENTIDADES', 'MUNICIPIOS']
catalogues = {}
for sheet in sheets:
  catalogue = pd.read_excel(nombre_cat, sheet_name='Cat√°logo ' + sheet)
  catalogue.columns = catalogue.columns.str.replace(' ', '_')
  catalogue.columns = catalogue.columns.str.replace('.', '')
  catalogue.columns = catalogue.columns.str.lower()
  new_catalogue = {sheet: catalogue}
  catalogues.update(new_catalogue)

catalogues

catalogues['SEXO']

"""##Perfilamiento

###Descripci√≥n General
"""

# dimensi√≥n de los datos
print('N√∫mero de filas: {}'.format(data.shape[0]))
print('N√∫mero de columnas: {}'.format(data.shape[1]))

# columnas (variables)
data.columns

# limpieza del nombre de las columnas, remover espacios, car√°cteres especiales y pasar a min√∫sculas
data.columns = data.columns.str.replace(' ', '_')
data.columns = data.columns.str.replace('.', '')
data.columns = data.columns.str.lower()

# calcular n√∫mero de valores nulos por columna
for col in data.columns:
  print('Valores nulos en "{}": {}'.format(col,data[col].isna().sum()))

# tipos de datos
data.dtypes

"""###Limpieza"""

# convertimos a fecha algunas columnas
def cast_datetime_cols(df):
    timestamp_cols = [col for col in df.columns if "fecha" in col]
    df[timestamp_cols] = df[timestamp_cols].apply(lambda date_col: pd.to_datetime(date_col, errors="coerce"), axis=0)
    return df

data = cast_datetime_cols(data)

data.head()

# unimos los datos con los catalogos para tener mejor entendimiento de ellos
data = (
    # unimos con el cat√°logo MUNICIPIOS y ENTIDADES
    data.merge(catalogues['de ENTIDADES'], how='left', left_on='entidad_res', right_on='clave_entidad').
    drop(columns=['entidad_res', 'abreviatura']).
    rename(columns={'entidad_federativa':'entidad_res'}).
    merge(catalogues['MUNICIPIOS'], how='left', left_on=['clave_entidad','municipio_res'], right_on=['clave_entidad','clave_municipio']).
    drop(columns=['municipio_res', 'clave_entidad', 'clave_municipio']).
    rename(columns={'municipio':'municipio_res'})
)

# unimos con el cat√°logo de ENTIDADES
entidades_cols = [col for col in data.columns if "entidad" in col and col != 'entidad_res']
for col in entidades_cols:
    data = (
        data.merge(catalogues['de ENTIDADES'], how='left', left_on=col, right_on='clave_entidad').
        drop(columns=[col, 'abreviatura', 'clave_entidad']).
        rename(columns={'entidad_federativa':col})
    )

# unimos con el cat√°logo SI_NO
sino_cols = ['intubado', 'neumonia', 'embarazo', 'habla_lengua_indig', 'diabetes', 'epoc', 'asma', 'inmusupr',
             'hipertension', 'otra_com', 'cardiovascular', 'obesidad', 'renal_cronica', 'tabaquismo', 
             'otro_caso', 'migrante', 'uci']
for col in sino_cols:
    data = (
        data.merge(catalogues['SI_NO'], how='left', left_on=col, right_on='clave').
        drop(columns=[col, 'clave']).
        rename(columns={'descripci√≥n':col})
    )

"""> **Nota:**
>
> Si ejecutaste una versi√≥n previa del cuaderno, notar√°s que en la siguiente secci√≥n aparec√≠a un error. A continuaci√≥n dejamos como un peque√±o par√©ntesis un poco m√°s de limpieza sobre el cuaderno.

1. Corregimos el nombre de las columnas:
"""

catalogues['RESULTADO'].columns

catalogues['RESULTADO'].columns = ['clave', 'descripci√≥n']
catalogues['RESULTADO'].columns

"""2. Removemos la (primera) fila que no nos es √∫til."""

catalogues['RESULTADO'] = catalogues['RESULTADO'].drop(index=0)

"""3. Convertimos el tipo de dato."""

catalogues['RESULTADO']['clave'] = catalogues['RESULTADO']['clave'].astype(int)

"""> Fin del par√©ntesis. Hasta esta secci√≥n, esta parte de limpieza permite continuar con el proceso de manera normal."""

# unimos otras columnnas que comparten l√≥gica
other_cols = ['origen', 'sector', 'sexo', 'tipo_paciente', 'nacionalidad', 'resultado']
for col, cat in zip(other_cols, [x.upper() for x in other_cols]):
    data = (
        data.merge(catalogues[cat], how='left', left_on=col, right_on='clave').
        drop(columns=[col, 'clave']).
        rename(columns={'descripci√≥n':col})
    )

# creamos algunas variables que podr√≠an ser √∫tiles despu√©s
data['defuncion'] = ~data.fecha_def.isna()
data['mes_def'] = data.fecha_def.dt.month
data['a√±o_def'] = data.fecha_def.dt.year
data['mes_ingreso'] = data.fecha_ingreso.dt.month
data['a√±o_ingreso'] = data.fecha_ingreso.dt.year

data.head()

"""###Filtros

**Distintas formas de filtrar lo mismo**
"""

# usando query
data.query('nacionalidad == "MEXICANA"').head(2)

# haciendo referencia a la columna como √≠ndice
data[data['nacionalidad'] == 'MEXICANA'].head(2)

# seleccionando directamente la columna que queremos filtrar
data[data.nacionalidad == 'MEXICANA'].head(2)

"""**Filtrado m√∫ltiple**"""

# usando query podemos poner en el string del query todas las condiciones que queramos
data.query('nacionalidad == "MEXICANA" & entidad_res == "CIUDAD DE M√âXICO"').head(2)

# usando el filtrado tradicional debemos encerrar en par√©ntesis cada condici√≥n que queremos que cumpla nuestro filtro
data[(data['nacionalidad'] == "MEXICANA") & (data.entidad_res == "CIUDAD DE M√âXICO")].head(2)

"""###Res√∫menes"""

# una columna, una m√©trica
data.groupby('sexo').edad.mean()

# una columna, varias m√©tricas
data.groupby('sexo').agg({'edad': ['min','mean','max']})

# varias columnas, una m√©trica
data.groupby('sexo').agg({'edad': 'mean', 'mes_ingreso': 'mean', 'mes_def': 'mean'})

# varias columnas, varias m√©tricas
data.groupby('sexo').agg({'edad': ['min','mean','max'], 'mes_ingreso': ['min','mean','max'], 'mes_def': ['min','mean','max']})

"""###Descripci√≥n por Tipo"""

# Filtrar por tipos generales (categ√≥ricas y num√©ricas)
numerical = data.select_dtypes(include='number')
categorical = data.select_dtypes(include=['object', 'bool', 'category', 'datetime64[ns]'])

numerical.head()

categorical.head()

# para conocer todos los tipo de datos
?data.select_dtypes

"""####Categ√≥ricas"""

# Cardinalidad - Valores √∫nicos por columna
for col in categorical.columns:
  print('Valores √∫nicos en "{}": {}'.format(col,categorical[col].nunique()))

# Unicidad - proporci√≥n de valores √∫nicos por columna
total = data.shape[0]
for col in categorical.columns:
  print('Porcentaje de valores √∫nicos en "{}": {}%'.format(col,round(categorical[col].nunique()/total*100,2)))

# Moda - valor que m√°s se repite en cada columna excepto los indicadores √∫nicos
for col in categorical.drop(columns='id_registro').columns:
  print('Valor m√°s popular en "{}": {}'.format(col, statistics.mode(categorical[col])))

"""####Num√©ricas"""

numerical.describe()

"""##An√°lisis Exploratorio

En esta secci√≥n responderemos algunas preguntas sobre el set de datos usando las herramientas que hemos visto hasta ahora
"""

# ¬øCu√°ntas pruebas por origen se realizan?
data.groupby('origen').id_registro.count()

data.origen.value_counts()

# ¬øCu√°ntas pruebas por sector se realizan?
data.sector.value_counts()

# ¬øCu√°ntos pacientes por sexo tenemos?
data.sexo.value_counts()

# ¬øCu√°l es la proporci√≥n de los pacientes por sexo?
data.sexo.value_counts(normalize=True)

# ¬øCu√°l es la proporci√≥n de resultados de las pruebas?
data.resultado.value_counts(normalize=True)

# ¬øCu√°ntas pruebas positivas tenemos en el set?
data[data.resultado == 'Positivo SARS-CoV-2'].id_registro.count()

# ¬øCu√°ntos casos positivos tenemos por mes?
data[data.resultado == 'Positivo SARS-CoV-2'].mes_ingreso.value_counts().sort_index()

# ¬øCu√°l es el resultado de las pruebas por sexo?
data.groupby(['sexo','resultado'])['id_registro'].count()

data.groupby('sexo').resultado.value_counts()

# ¬øQu√© proporci√≥n de resultados de pruebas tenemos por sexo?
data.groupby('sexo').resultado.value_counts(normalize=True)

# ¬øCu√°l es la edad de los pacientes por sexo?
data.groupby('sexo').edad.describe()

def q25(x):
  return x.quantile(0.25)

def q75(x):
  return x.quantile(0.75)

data.groupby('sexo').agg({'edad': ['min', q25, 'median', q75, 'max']})

# ¬øCu√°l es la edad de los pacientes dependiendo de si son intubados o no?
data.groupby('intubado').edad.describe()

data.groupby('intubado').agg({'edad': ['min', q25, 'median', q75, 'max']})

# ¬øCu√°l es la edad m√°xima y cu√°l es la m√≠nima de los pacientes fallecidos?
edad_def_max = data[data.defuncion].edad.max()
data[data.defuncion & (data.edad == edad_def_max)]

edad_def_min = data[data.defuncion].edad.min()
data[data.defuncion & (data.edad == edad_def_min)]

# ¬øCu√°l es la edad de los pacientes que fallecen?
data.groupby('defuncion').edad.describe()

# ¬øCu√°ntas defunciones tenemos por mes?
data[data.defuncion].mes_def.value_counts().sort_index()

# ¬øCu√°l es la proporci√≥n de di√°beticos para las defunciones?
data.groupby('diabetes').defuncion.value_counts(normalize=True)

# ¬øCu√°l es la proporci√≥n de asm√°ticos para las defunciones?
data.groupby('asma').defuncion.value_counts(normalize=True)

