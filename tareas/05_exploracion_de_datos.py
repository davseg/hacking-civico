# -*- coding: utf-8 -*-
"""05_Exploracion_de_datos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/CodeandoMexico/hacking-civico/blob/master/notebooks/05_Exploracion_de_datos.ipynb

<p align="center">
<img src="http://codeandomexico.org/resources/img/codeandomexico.png" width="500" alt="Codeando M칠xico"><br>
<a href="http://www.codeandomexico.org/" target="_blank"><img src="https://img.shields.io/badge/website-CodeandoMexico-00D88E.svg"></a>
<a href="http://slack.codeandomexico.org/" target="_blank"><img src="https://img.shields.io/badge/slack-CodeandoMexico-EC0E4F.svg"></a>
</p>
<!-- __ -->

# Curso de Datos Abiertos y Hacking C칤vico

Este curso tiene como objetivo habilitar las capacidades de la ciudadani패a y los servidores p칰blicos en el uso y generaci칩n de datos abiertos para el bien com칰n. Puedes encontrar m치s informaci칩n [aqu칤](https://github.com/CodeandoMexico/hacking-civico).

# Exploraci칩n de datos: COVID-19 en M칠xico

En este cuaderno aprenderemos algunas bases de exploraci칩n de datos. Los datos a utilizar son los datos abiertos sobre COVID-19 en M칠xico, los cuales pueden ser accedidos directamente desde el portal: https://www.gob.mx/salud/documentos/datos-abiertos-152127

Del portal de datos abiertos podemos encontrar dos enlaces, uno para descargar el conjunto de datos y otro para descargar el diccionario; as칤 que podemos automatizar el proceso de descarga y descompresi칩n de la informaci칩n.

Para obtener los datos, s칩lo basta que ejecutes la siguiente l칤nea de c칩digo, que contiene el comando de descarga de la informaci칩n.
"""

# Para descargar el conjunto de datos
!wget http://datosabiertos.salud.gob.mx/gobmx/salud/datos_abiertos/datos_abiertos_covid19.zip

# Para descargar el diccionario de los datos
!wget http://epidemiologia.salud.gob.mx/gobmx/salud/datos_abiertos/diccionario_datos_covid19.zip

# Descomprimimos ambas carpetas y movemos archivos
!unzip datos_abiertos_covid19.zip
!unzip diccionario_datos_covid19.zip
!mv ./diccionario_datos_covid19/*.xlsx .
!mv *COVID19MEXICO.csv COVID19MEXICO.csv

# Eliminamos las carpetas comprimidas
!rm -rf diccionario_datos_covid19
!rm datos_abiertos_covid19.zip
!rm diccionario_datos_covid19.zip

"""Hasta este punto, si abres la barra lateral izaquiera, deber칤as ser capaz de encontrar los datos:

- `COVID19MEXICO.csv`
- `Catalogos_0412.xlsx`
- `Descriptores_0419.xlsx`

游녣游낖

## Carga

Ahora que tenemos los datos, procederemos a cargarlos. Para cargar los datos, primero importaremos algunos paquetes de Python, pues su funcionalidad nos ser치 muy util.
"""

import statistics

import pandas as pd
import numpy as np

# Especificamos el nombre del archivo por abrir
nombre_archivo = 'COVID19MEXICO.csv'

# Utilizamos la funci칩n de Pandas para cargar un archivo CSV
data = pd.read_csv(nombre_archivo, encoding='latin-1')

"""Mostramos la cabeza (primeros elementos del archivo)."""

data.head()

"""Ahora procedemos a cargar el archivo con los descriptores."""

nombre_diccionario = 'Descriptores_0419.xlsx'
diccionario = pd.read_excel(nombre_diccionario)

diccionario

"""Finalmente, cargamos el rachivo de cat치logos."""

nombre_cat = 'Catalogos_0412.xlsx'
sheets = ['ORIGEN', 'SECTOR', 'SEXO', 'TIPO_PACIENTE', 'SI_NO', 'NACIONALIDAD', 'RESULTADO', 'de ENTIDADES', 'MUNICIPIOS']
catalogues = {}
for sheet in sheets:
  catalogue = pd.read_excel(nombre_cat, sheet_name='Cat치logo ' + sheet)
  catalogue.columns = catalogue.columns.str.replace(' ', '_')
  catalogue.columns = catalogue.columns.str.replace('.', '')
  catalogue.columns = catalogue.columns.str.lower()
  new_catalogue = {sheet: catalogue}
  catalogues.update(new_catalogue)

catalogues

catalogues['SEXO']

"""##Perfilamiento

###Descripci칩n General
"""

# dimensi칩n de los datos
print('N칰mero de filas: {}'.format(data.shape[0]))
print('N칰mero de columnas: {}'.format(data.shape[1]))

# columnas (variables)
data.columns

# limpieza del nombre de las columnas, remover espacios, car치cteres especiales y pasar a min칰sculas
data.columns = data.columns.str.replace(' ', '_')
data.columns = data.columns.str.replace('.', '')
data.columns = data.columns.str.lower()

# calcular n칰mero de valores nulos por columna
for col in data.columns:
  print('Valores nulos en "{}": {}'.format(col,data[col].isna().sum()))

# tipos de datos
data.dtypes

"""###Limpieza"""

# convertimos a fecha algunas columnas
def cast_datetime_cols(df):
    timestamp_cols = [col for col in df.columns if "fecha" in col]
    df[timestamp_cols] = df[timestamp_cols].apply(lambda date_col: pd.to_datetime(date_col, errors="coerce"), axis=0)
    return df

data = cast_datetime_cols(data)

data.head()

# unimos los datos con los catalogos para tener mejor entendimiento de ellos
data = (
    # unimos con el cat치logo MUNICIPIOS y ENTIDADES
    data.merge(catalogues['de ENTIDADES'], how='left', left_on='entidad_res', right_on='clave_entidad').
    drop(columns=['entidad_res', 'abreviatura']).
    rename(columns={'entidad_federativa':'entidad_res'}).
    merge(catalogues['MUNICIPIOS'], how='left', left_on=['clave_entidad','municipio_res'], right_on=['clave_entidad','clave_municipio']).
    drop(columns=['municipio_res', 'clave_entidad', 'clave_municipio']).
    rename(columns={'municipio':'municipio_res'})
)

# unimos con el cat치logo de ENTIDADES
entidades_cols = [col for col in data.columns if "entidad" in col and col != 'entidad_res']
for col in entidades_cols:
    data = (
        data.merge(catalogues['de ENTIDADES'], how='left', left_on=col, right_on='clave_entidad').
        drop(columns=[col, 'abreviatura', 'clave_entidad']).
        rename(columns={'entidad_federativa':col})
    )

# unimos con el cat치logo SI_NO
sino_cols = ['intubado', 'neumonia', 'embarazo', 'habla_lengua_indig', 'diabetes', 'epoc', 'asma', 'inmusupr',
             'hipertension', 'otra_com', 'cardiovascular', 'obesidad', 'renal_cronica', 'tabaquismo', 
             'otro_caso', 'migrante', 'uci']
for col in sino_cols:
    data = (
        data.merge(catalogues['SI_NO'], how='left', left_on=col, right_on='clave').
        drop(columns=[col, 'clave']).
        rename(columns={'descripci칩n':col})
    )

"""> **Nota:**
>
> Si ejecutaste una versi칩n previa del cuaderno, notar치s que en la siguiente secci칩n aparec칤a un error. A continuaci칩n dejamos como un peque침o par칠ntesis un poco m치s de limpieza sobre el cuaderno.

1. Corregimos el nombre de las columnas:
"""

catalogues['RESULTADO'].columns

catalogues['RESULTADO'].columns = ['clave', 'descripci칩n']
catalogues['RESULTADO'].columns

"""2. Removemos la (primera) fila que no nos es 칰til."""

catalogues['RESULTADO'] = catalogues['RESULTADO'].drop(index=0)

"""3. Convertimos el tipo de dato."""

catalogues['RESULTADO']['clave'] = catalogues['RESULTADO']['clave'].astype(int)

"""> Fin del par칠ntesis. Hasta esta secci칩n, esta parte de limpieza permite continuar con el proceso de manera normal."""

# unimos otras columnnas que comparten l칩gica
other_cols = ['origen', 'sector', 'sexo', 'tipo_paciente', 'nacionalidad', 'resultado']
for col, cat in zip(other_cols, [x.upper() for x in other_cols]):
    data = (
        data.merge(catalogues[cat], how='left', left_on=col, right_on='clave').
        drop(columns=[col, 'clave']).
        rename(columns={'descripci칩n':col})
    )

# creamos algunas variables que podr칤an ser 칰tiles despu칠s
data['defuncion'] = ~data.fecha_def.isna()
data['mes_def'] = data.fecha_def.dt.month
data['a침o_def'] = data.fecha_def.dt.year
data['mes_ingreso'] = data.fecha_ingreso.dt.month
data['a침o_ingreso'] = data.fecha_ingreso.dt.year

data.head()

"""###Filtros

**Distintas formas de filtrar lo mismo**
"""

# usando query
data.query('nacionalidad == "MEXICANA"').head(2)

# haciendo referencia a la columna como 칤ndice
data[data['nacionalidad'] == 'MEXICANA'].head(2)

# seleccionando directamente la columna que queremos filtrar
data[data.nacionalidad == 'MEXICANA'].head(2)

"""**Filtrado m칰ltiple**"""

# usando query podemos poner en el string del query todas las condiciones que queramos
data.query('nacionalidad == "MEXICANA" & entidad_res == "CIUDAD DE M칄XICO"').head(2)

# usando el filtrado tradicional debemos encerrar en par칠ntesis cada condici칩n que queremos que cumpla nuestro filtro
data[(data['nacionalidad'] == "MEXICANA") & (data.entidad_res == "CIUDAD DE M칄XICO")].head(2)

"""###Res칰menes"""

# una columna, una m칠trica
data.groupby('sexo').edad.mean()

# una columna, varias m칠tricas
data.groupby('sexo').agg({'edad': ['min','mean','max']})

# varias columnas, una m칠trica
data.groupby('sexo').agg({'edad': 'mean', 'mes_ingreso': 'mean', 'mes_def': 'mean'})

# varias columnas, varias m칠tricas
data.groupby('sexo').agg({'edad': ['min','mean','max'], 'mes_ingreso': ['min','mean','max'], 'mes_def': ['min','mean','max']})

"""###Descripci칩n por Tipo"""

# Filtrar por tipos generales (categ칩ricas y num칠ricas)
numerical = data.select_dtypes(include='number')
categorical = data.select_dtypes(include=['object', 'bool', 'category', 'datetime64[ns]'])

numerical.head()

categorical.head()

# para conocer todos los tipo de datos
?data.select_dtypes

"""####Categ칩ricas"""

# Cardinalidad - Valores 칰nicos por columna
for col in categorical.columns:
  print('Valores 칰nicos en "{}": {}'.format(col,categorical[col].nunique()))

# Unicidad - proporci칩n de valores 칰nicos por columna
total = data.shape[0]
for col in categorical.columns:
  print('Porcentaje de valores 칰nicos en "{}": {}%'.format(col,round(categorical[col].nunique()/total*100,2)))

# Moda - valor que m치s se repite en cada columna excepto los indicadores 칰nicos
for col in categorical.drop(columns='id_registro').columns:
  print('Valor m치s popular en "{}": {}'.format(col, statistics.mode(categorical[col])))

"""####Num칠ricas"""

numerical.describe()

"""##An치lisis Exploratorio

En esta secci칩n responderemos algunas preguntas sobre el set de datos usando las herramientas que hemos visto hasta ahora
"""

# 쮺u치ntas pruebas por origen se realizan?
data.groupby('origen').id_registro.count()

data.origen.value_counts()

# 쮺u치ntas pruebas por sector se realizan?
data.sector.value_counts()

# 쮺u치ntos pacientes por sexo tenemos?
data.sexo.value_counts()

# 쮺u치l es la proporci칩n de los pacientes por sexo?
data.sexo.value_counts(normalize=True)

# 쮺u치l es la proporci칩n de resultados de las pruebas?
data.resultado.value_counts(normalize=True)

# 쮺u치ntas pruebas positivas tenemos en el set?
data[data.resultado == 'Positivo SARS-CoV-2'].id_registro.count()

# 쮺u치ntos casos positivos tenemos por mes?
data[data.resultado == 'Positivo SARS-CoV-2'].mes_ingreso.value_counts().sort_index()

# 쮺u치l es el resultado de las pruebas por sexo?
data.groupby(['sexo','resultado'])['id_registro'].count()

data.groupby('sexo').resultado.value_counts()

# 쯈u칠 proporci칩n de resultados de pruebas tenemos por sexo?
data.groupby('sexo').resultado.value_counts(normalize=True)

# 쮺u치l es la edad de los pacientes por sexo?
data.groupby('sexo').edad.describe()

def q25(x):
  return x.quantile(0.25)

def q75(x):
  return x.quantile(0.75)

data.groupby('sexo').agg({'edad': ['min', q25, 'median', q75, 'max']})

# 쮺u치l es la edad de los pacientes dependiendo de si son intubados o no?
data.groupby('intubado').edad.describe()

data.groupby('intubado').agg({'edad': ['min', q25, 'median', q75, 'max']})

# 쮺u치l es la edad m치xima y cu치l es la m칤nima de los pacientes fallecidos?
edad_def_max = data[data.defuncion].edad.max()
data[data.defuncion & (data.edad == edad_def_max)]

edad_def_min = data[data.defuncion].edad.min()
data[data.defuncion & (data.edad == edad_def_min)]

# 쮺u치l es la edad de los pacientes que fallecen?
data.groupby('defuncion').edad.describe()

# 쮺u치ntas defunciones tenemos por mes?
data[data.defuncion].mes_def.value_counts().sort_index()

# 쮺u치l es la proporci칩n de di치beticos para las defunciones?
data.groupby('diabetes').defuncion.value_counts(normalize=True)

# 쮺u치l es la proporci칩n de asm치ticos para las defunciones?
data.groupby('asma').defuncion.value_counts(normalize=True)

